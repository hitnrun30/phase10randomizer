from flask import Flask, Response, request, jsonify
import html as html_mod
import json
import os
import subprocess
import sys

import phase10config

app = Flask(__name__)

# Paths live next to this file (works in dev and in /www/phase10)
CONFIG_JSON_PATH = os.path.join(os.path.dirname(__file__), "phase10config.json")
PHASE10_HTML_PATH = os.path.join(os.path.dirname(__file__), "phase10_html.py")


def _save_config_json(cfg: dict) -> None:
    """
    Persist only the basic, JSON-safe config fields to phase10config.json.
    PHASE_PROB_CACHE is always an empty dict in the file.
    """
    try:
        allowed_keys = [
            "MC_TRIALS_DEFAULT",
            "COLOR_RAND",
            "WILD_RAND",
            "TYPE_MAX_PER_PHASE",
            "USE_MONTE_CARLO",
            "SHOW_PHASE_PROBABILITY",
            "MIN_CARDS_PER_PHASE",
            "TYPE_MAX_PER_TYPE_GLOBAL",
            "HTML_TIMEOUT_SECONDS",
        ]

        safe_cfg = {k: cfg[k] for k in allowed_keys if k in cfg}
        # Keep PHASE_PROB_CACHE in JSON as empty, never serialize the live cache
        safe_cfg["PHASE_PROB_CACHE"] = {}

        with open(CONFIG_JSON_PATH, "w", encoding="utf-8") as f:
            json.dump(safe_cfg, f, indent=4)
    except Exception as e:
        app.logger.error("Could not write %s: %s", CONFIG_JSON_PATH, e)


def _build_config_from_request() -> dict:
    """
    Start from phase10config.CONFIG (defaults + JSON),
    overlay query params, return merged config. Persist JSON if changed.
    """
    original_cfg = dict(phase10config.CONFIG)
    cfg = dict(original_cfg)

    # --- booleans ---
    val = request.args.get("use_mc")
    if val is not None:
        cfg["USE_MONTE_CARLO"] = (val == "1")

    val = request.args.get("show_prob")
    if val is not None:
        cfg["SHOW_PHASE_PROBABILITY"] = (val == "1")

    # --- helper for ints ---
    def override_int(qp_key: str, cfg_key: str):
        v = request.args.get(qp_key)
        if v is not None:
            try:
                cfg[cfg_key] = int(v)
            except ValueError:
                pass

    override_int("mc_trials", "MC_TRIALS_DEFAULT")
    override_int("color_rand", "COLOR_RAND")
    override_int("wild_rand", "WILD_RAND")
    override_int("max_per_phase", "TYPE_MAX_PER_PHASE")
    override_int("min_cards", "MIN_CARDS_PER_PHASE")
    override_int("max_per_type", "TYPE_MAX_PER_TYPE_GLOBAL")

    # timeout is float
    v = request.args.get("html_timeout")
    if v is not None:
        try:
            cfg["HTML_TIMEOUT_SECONDS"] = float(v)
        except ValueError:
            pass

    # Persist and update global CONFIG if anything changed
    _save_config_json(cfg)
    phase10config.CONFIG = cfg

    return cfg


@app.get("/health")
def health():
    return jsonify({"status": "ok"}), 200


@app.get("/phase10/html")
def phase10_html():
    """
    HTTP wrapper that:
    - builds config from defaults + query params
    - saves phase10config.json if changed
    - runs phase10_html.py as a separate process with a hard timeout
    - returns its stdout as the <li> list
    """
    try:
        cfg = _build_config_from_request()
        timeout_sec = float(cfg.get("HTML_TIMEOUT_SECONDS", 5.0))

        cmd = [sys.executable, PHASE10_HTML_PATH]
        app.logger.info("Running %s with timeout=%.2fs", cmd, timeout_sec)

        proc = subprocess.run(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            timeout=timeout_sec,
            cwd=os.path.dirname(PHASE10_HTML_PATH),
        )

        if proc.returncode != 0:
            # Engine failed; show stderr for debugging
            msg = (
                f"Phase10 engine exited with code {proc.returncode}. "
                f"Stderr follows below."
            )
            safe_msg = html_mod.escape(msg, quote=True)
            safe_err = html_mod.escape(proc.stderr, quote=True)
            body = (
                f"<li>{safe_msg}</li>"
                f"<pre style='white-space:pre-wrap;font-size:0.8rem;"
                f"color:#ffdddd;background:#330000;padding:0.5rem;"
                f"border-radius:0.25rem;'>{safe_err}</pre>"
            )
            app.logger.error("Phase10 engine error: %s", proc.stderr)
            return Response(body, mimetype="text/html", status=200)

        text = proc.stdout.strip()
        if not text:
            return Response(
                "<li>No phases were generated by the Phase10 engine.</li>",
                mimetype="text/html",
                status=200,
            )

        return Response(text, mimetype="text/html", status=200)

    except subprocess.TimeoutExpired:
        msg = (
            f"Phase generation exceeded HTML_TIMEOUT_SECONDS "
            f"({cfg.get('HTML_TIMEOUT_SECONDS', 5.0)}s). "
            f"Try lowering MC_TRIALS_DEFAULT or disabling probability display."
        )
        safe = html_mod.escape(msg, quote=True)
        return Response(f"<li>{safe}</li>", mimetype="text/html", status=200)

    except Exception:
        import traceback
        tb = traceback.format_exc()
        app.logger.error("Phase10 service error:\n%s", tb)
        safe_tb = html_mod.escape(tb, quote=True)
        body = (
            "<li>Error: Python generation failed.</li>"
            f"<pre style='white-space:pre-wrap;font-size:0.8rem;"
            f"color:#ffdddd;background:#330000;padding:0.5rem;"
            f"border-radius:0.25rem;'>{safe_tb}</pre>"
        )
        return Response(body, mimetype="text/html", status=200)


if __name__ == "__main__":
    # Dev: run directly on Windows
    app.run(host="127.0.0.1", port=5001, debug=True)
